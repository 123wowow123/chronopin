'use strict';

(function() {

  function PinGroupsFactory(modelInjector) {
    let Pin, PinGroup;

    function _convertUTCDateToLocalDate(date) {
      let newDate = new Date(date.getTime());
      newDate.setHours(0);
      newDate.setMinutes(0);
      newDate.setMilliseconds(0);
      newDate.setSeconds(0);
      return newDate;
    }

    function _sortDate(a, b) {
      return _getSortDateKey(a) - _getSortDateKey(b);
    }

    function _getSortDateKey(a) {
      return a.utcStartDateTime.getTime();
    }

    function _sortedPush(array, value) {
      array.splice(_.sortedIndexBy(array, value, _getSortDateKey), 0, value);
    }

    function _getKey(obj) {
      let dateTime = obj.utcStartDateTime;
      dateTime = _convertUTCDateToLocalDate(dateTime);
      return dateTime;
    }

    function _createPins(pins) {
      return pins.map(p => new Pin(p));
    }

    return class PinGroups extends Array {
      constructor(...args) {
        // Lazy load to prevent Angular circular dependency
        Pin = Pin || modelInjector.getPin();
        PinGroup = PinGroup || modelInjector.getPinGroup();

        // Pins collection is pushed to super Array
        super(...args);
        if (this.length) {
          this.sort(_sortDate);
        }
      }

      mergePins(pins) {
        if (!pins) {
          return 0;
        }
        let createCount = 0
        pins = _createPins(pins);
        pins.forEach(pin => {
          let key = _getKey(pin);
          let foundPinGroup = this.findPinGroupByKey(key);
          if (foundPinGroup) {
            foundPinGroup.mergePins([pin]);
          } else {
            createCount++;
            let pg = new PinGroup(key, pin);
            _sortedPush(this, pg);
          }
        });
        return createCount;
      }

      createPinGroupByKey(utcStartDateTime) {
        if (!utcStartDateTime) {
          return 0;
        }
        let createCount = 0

        let key = _convertUTCDateToLocalDate(utcStartDateTime);
        let foundPinGroup = this.findPinGroupByKey(key);
        if (!foundPinGroup) {
          createCount++;
          let pg = new PinGroup(key);
          _sortedPush(this, pg);
        }

        return createCount;
      }

      findPinGroupByKey(utcStartDateTime) {
        return _.find(this, {
          utcStartDateTime: utcStartDateTime
        });
      }

      findPinGroupByDateTime(utcStartDateTime) {
        let minPositiveDayDelta,
          minPositiveDayDeltaKey,
          minNegativeDayDelta,
          minNegativeDayDeltaKey,
          m = 0,
          n = this.length - 1;
        while (m <= n) {
          let k = (n + m) >> 1;
          let daySince = this[k].getDateSince(utcStartDateTime);

          if (daySince < 0) {
            if (!minNegativeDayDelta || daySince > minPositiveDayDelta) {
              minNegativeDayDelta = daySince;
              minNegativeDayDeltaKey = k;
            }
            m = k + 1;
          } else if (daySince > 0) {
            if (!minPositiveDayDelta || daySince < minPositiveDayDelta) {
              minPositiveDayDelta = daySince;
              minPositiveDayDeltaKey = k;
            }
            n = k - 1;
          } else {
            return this[k];
          }
        }

        if (!!minPositiveDayDelta) {
          return this[minPositiveDayDeltaKey];
        } else {
          return this[minNegativeDayDeltaKey]
        }
      }

      removePinById(id) {
        for (var i = 0; i < this.length; i++) {
          let pinGroup = this[i];
          let removed = pinGroup.removePinById(id);
          if (removed) {
            return removed;
          }
        }
      }

      static getKey(pin) {
        return _getKey(pin);
      }

    };

  }

  angular.module('chronopinNodeApp.model')
    .factory('PinGroupsFactory', PinGroupsFactory);

})();
