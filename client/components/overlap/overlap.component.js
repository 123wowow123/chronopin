'use strict';

(function () {

  class OverlapController {

    constructor($scope, $element) {

      // Generated by CoffeeScript 1.6.3
      /*
      2013.09.17
      Author: Pavel Kabir
      Usage under MIT license: http://opensource.org/licenses/MIT
      */

      // http://jsfiddle.net/wh1t3cAt1k/fLXCJ/2/

      this.$scope = $scope;
      this.$element = $element;

      /* jshint ignore:start */
      var KBPoint, KBRectangle, kbAssert, kbAssertExists, kbAssertNonNegative, kbAssertNotZero, kbAssertNumber, kbAssertPositive, kbElementArea, kbForAll, kbGetAbsolutePositionRectangle,
        __slice = [].slice;

      kbAssert = function (condition, message) {
        if (message == null) {
          message = 'unspecified error';
        }
        if (!condition) {
          throw 'runtime assertion failed: ' + message;
        }
        return true;
      };

      kbAssertExists = function () {
        var values;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return kbForall(values, function (x) {
          return kbAssert(x != null, 'value should not be null or undefined');
        });
      };

      kbAssertNumber = function () {
        var values;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return kbForAll(values, function (x) {
          return kbAssert(typeof x === 'number', 'the value should be a number');
        });
      };

      kbAssertNotZero = function () {
        var values;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return kbForAll(values, function (x) {
          kbAssertNumber(x);
          return kbAssert(x !== 0, 'the value should not be zero');
        });
      };

      kbAssertNonNegative = function () {
        var values;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return kbForAll(values, function (x) {
          kbAssertNumber(x);
          return kbAssert(x >= 0, 'the value should not be negative');
        });
      };

      kbAssertPositive = function () {
        var values;
        values = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return kbForAll(values, function (x) {
          kbAssertNumber(x);
          return kbAssert(x > 0, 'the value should be positive');
        });
      };

      kbForAll = function (array, predicate) {
        var element, result, _i, _len;
        result = true;
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          element = array[_i];
          if (!predicate(element)) {
            result = false;
            break;
          }
        }
        return result;
      };

      KBPoint = (function () {
        function KBPoint(x, y) {
          this.x = x;
          this.y = y;
          kbAssertNumber(this.x);
          kbAssertNumber(this.y);
        }

        KBPoint.prototype.horizontalDistanceTo = function (another) {
          return Math.abs(this.x - another.x);
        };

        KBPoint.prototype.verticalDistanceTo = function (another) {
          return Math.abs(this.y - another.y);
        };

        KBPoint.prototype.distanceTo = function (another) {
          return Math.sqrt(Math.pow(KBPoint.horizontalDistanceTo(another, 2)) + Math.pow(KBPoint.verticalDistanceTo(another, 2)));
        };

        KBPoint.prototype.withOffsetX = function (xOffset) {
          kbAssertPositive(xOffset);
          return new KBPoint(this.x + xOffset, this.y);
        };

        KBPoint.prototype.withOffsetY = function (yOffset) {
          kbAssertPositive(yOffset);
          return new KBPoint(this.x, this.y + yOffset);
        };

        KBPoint.prototype.withOffset = function (xOffset, yOffset) {
          kbAssertNumber(xOffset);
          kbAssertNumber(yOffset);
          return this.withOffsetX(xOffset).withOffsetY(yOffset);
        };

        KBPoint.prototype.atLeastFarAs = function (another) {
          return this.x >= another.x && this.y >= another.y;
        };

        KBPoint.prototype.atMostFarAs = function (another) {
          return this.x <= another.x && this.y <= another.y;
        };

        KBPoint.prototype.equalTo = function (another, epsilon) {
          if (epsilon == null) {
            epsilon = 0;
          }
          if (epsilon === 0) {
            return this.x === another.x && this.y === another.y;
          } else {
            return this.distanceTo(another) < epsilon;
          }
        };

        KBPoint.prototype.asString = function () {
          return '(' + this.x + ', ' + this.y + ')';
        };

        return KBPoint;

      })();

      KBRectangle = (function () {
        function KBRectangle(topLeft, bottomRight) {
          this.topLeft = topLeft;
          this.bottomRight = bottomRight;
        }

        KBRectangle.fromPoints = function (pointTopLeft, pointBottomRight) {
          kbAssert(pointTopLeft.atMostFarAs(pointBottomRight), "The first point should be 'less' than the second."); // jshint ignore:line
          return new KBRectangle(pointTopLeft, pointBottomRight);
        };

        KBRectangle.fromOriginAndSize = function (origin, width, height) {
          kbAssertPositive(width);
          kbAssertPositive(height);
          return KBRectangle.fromPoints(origin, origin.withOffset(width, height));
        };

        KBRectangle.fromCoordinatesAndSize = function (x, y, width, height) {
          return KBRectangle.fromOriginAndSize(new KBPoint(x, y), width, height);
        };

        KBRectangle.fromCoordinates = function (x1, y1, x2, y2) {
          return KBRectangle.fromPoints(new KBPoint(x1, y1), new KBPoint(x2, y2));
        };

        KBRectangle.empty = function () {
          return KBRectangle.fromCoordinates(0, 0, 0, 0);
        };

        KBRectangle.prototype.withOffsetX = function (xOffset) {
          return new KBRectangle(this.topLeft.withOffsetX(xOffset), this.bottomRight.withOffsetX(xOffset));
        };

        KBRectangle.prototype.withOffsetY = function (yOffset) {
          return new KBRectangle(this.topLeft.withOffsetY(yOffset), this.bottomRight.withOffsetY(yOffset));
        };

        KBRectangle.prototype.withOffset = function (xOffset, yOffset) {
          return this.withOffsetX(xOffset).withOffsetY(yOffset);
        };

        KBRectangle.prototype.width = function () {
          return this.topLeft.horizontalDistanceTo(this.bottomRight);
        };

        KBRectangle.prototype.height = function () {
          return this.topLeft.verticalDistanceTo(this.bottomRight);
        };

        KBRectangle.prototype.area = function () {
          return this.width() * this.height();
        };

        KBRectangle.prototype.containsPoint = function (point) {
          return point.x >= this.topLeft.x && point.x <= this.bottomRight.x && point.y >= this.topLeft.y && point.y <= this.bottomRight.y;
        };

        KBRectangle.prototype.containsRectangle = function (rectangle) {
          return this.topLeft.atMostFarAs(rectangle.topLeft && this.bottomRight.atLeastFarAs(rectangle.bottomRight));
        };

        KBRectangle.prototype.intersectionWith = function (another) {
          var x1, x2, y1, y2;
          x1 = Math.max(this.topLeft.x, another.topLeft.x);
          y1 = Math.max(this.topLeft.y, another.topLeft.y);
          x2 = Math.min(this.bottomRight.x, another.bottomRight.x);
          y2 = Math.min(this.bottomRight.y, another.bottomRight.y);
          if (new KBPoint(x1, y1).atMostFarAs(new KBPoint(x2, y2))) {
            return KBRectangle.fromCoordinates(x1, y1, x2, y2);
          } else {
            return KBRectangle.empty();
          }
        };

        KBRectangle.prototype.equalTo = function (another) {
          return this.topLeft.equalTo(another.topLeft) && this.bottomRight.equalTo(another.bottomRight);
        };

        KBRectangle.prototype.isIntersectingWith = function (another) {
          return !this.intersectionWith(another).equalTo(KBRectangle.empty() || this.containsPoint(new KBPoint(0, 0)) && another.containsPoint(new KBPoint(0, 0)));
        };

        KBRectangle.prototype.asString = function () {
          return 'Rectangle Origin (top-left): (' + this.topLeft.x + ', ' + this.topLeft.y + ') End (bottom-right): (' + this.bottomRight.x + ', ' + this.bottomRight.y + ').';
        };

        return KBRectangle;

      })();

      this.KBRectangle = KBRectangle;
      /* jshint ignore:end */
    }

    $onInit() {
      // The actual page code goes here
      this._namespace = '.overlap_' + this.$scope.$id;
      $(() => {
        $(window).on('resize' + this._namespace, () => {
          this.checkOverlap();
        });
      });
      this.checkOverlap();
    }

    kbGetAbsolutePositionRectangle(jQueryElement) {
      function getInnerHeight(elm) {
        var computed = getComputedStyle(elm),
          padding = parseInt(computed.paddingTop) + parseInt(computed.paddingBottom);

        return elm.clientHeight - padding
      }

      let height, topx, leftx, width;
      topx = jQueryElement[0].offsetTop;
      leftx = jQueryElement[0].offsetLeft;
      width = jQueryElement[0].offsetWidth;;
      height = getInnerHeight(jQueryElement[0]);
      return this.KBRectangle.fromCoordinatesAndSize(leftx, topx, width, height);
    }

    kbElementArea(jQueryElement) {
      return this.kbGetAbsolutePositionRectangle(jQueryElement).area();
    }

    checkOverlap() {
      let thisEle = this.$element;
      let otherEle = $('#' + this.overlapId);
      let positionRectangle1 = this.kbGetAbsolutePositionRectangle(thisEle);
      let positionRectangle2 = this.kbGetAbsolutePositionRectangle(otherEle);
      let intersectionRectangle = positionRectangle1.intersectionWith(positionRectangle2);
      let area = 1.0 * intersectionRectangle.area() / positionRectangle1.area();

      this.onOverlap({
        $event: {
          isOverlapping: !!area
        }
      });
    }

    $onDestroy() {
      $(window).off('resize' + this._namespace);
    }
  }

  angular.module('chronopinNodeApp')
    .directive('overlap',
      () => ({
        scope: {},
        restrict: 'A',
        controller: OverlapController,
        bindToController: {
          onOverlap: '&',
          overlapId: '='
        }
      })

    );

})();
